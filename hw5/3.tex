\documentclass{article}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{tikz}
\usetikzlibrary{positioning,automata}
\usepackage{array}
\usepackage{mathtools}
\usepackage{graphicx}

\begin{document}
\section*{\huge Homework Sheet 5}
\begin{flushright}
   \textbf{Author: Abdullah Oğuz Topçuoğlu \& Yousef Mostafa Farouk}
\end{flushright}

% Note: For grammars, we will use the following convention unless otherwise specified: we will
% assume that the starting symbol is the first nonterminal on the left-hand side of the first production
% rule and that the terminals are the lower-case letters and nonterminals the upper-case letters.
% Task 1 (4 points)
% Consider the context-free grammar G = (Σ, V, S, P) with Σ = {a, b}, V = {S, A} and the
% productions P
% S → aSb | bSa | aAa | bAb
% A → aA | bA | ε .
% 1. For the following words, say if the word is in L(G), and, if yes, give a derivation:
% (a) ababb
% (b) baaba
% (c) baabb
% 2. Characterize the language L(G) and give a short argument why your characterization is
% correct.
% Task 2 (6 points) Design a grammar G for each of the following two languages over the alphabet
% Σ and give a brief explanation of your construction.
% 1. L1 = {a
% 2
% n
% | n ∈ IN} over Σ = {a}.
% 2. L2 = { a
% n
% b
% na
% n
% b
% n
% | n ∈ IN } over Σ = {a, b}.
% Task 3 (6 points) This problem is about a machine that we call “non-deterministic counter
% push down automaton” (NCPDA). It is very similar to a PDA, the main difference being
% the content of the stack. In contrast ot PDAs the stack does not contain symbols from a
% finite alphabet, but rather integers of arbitrary size. The automaton can make use of the
% stack in the follwoing way: it can test whether or not the top number in the stack equals
% some fixed number. It can increment the top number or decrement that number. Should it
% become negative, the automaton gets stuck. The machine can put a new number (counter)
% on top of the stack, initialzed to 0 (Push), which is then the new top number on the stack.
% The machine can remove the top counter from the stack (Pop). The bottom of stack is an
% unmutable counter that is initialized to -1. Any attempt in changing it results in the machine
% getting stuck.
% Overall the NCPDA works like a PDA: There is a finite state set and a finite number of rules.
% Whether a rule is applicable depends on the current state, on the next symbol of the input,
% and on the value of the counter on top of the stack (whether it equals some number or not).
% A step of the computation changes the state, changes the top of the stack as described above,
% and possibly consumes one symbol of the input.
% 1. Give a formal definition of the concept of NCPDA. For the purpose define the notions of
% configuration space, computing step relation, acceptance of an input, NCPDA-language.
% 2. Show that { a
% n
% b
% mc
% md
% n
% | n, m ∈ N } is an NCPDA language.
% 3. What is the relationship between NPDA languages (i.e. context-free languages) and
% NCPDA-languages? Prove your answer.

\section*{Task 3}

\subsection*{(1)}
A Non deterministic Counter Push Down Automaton (NCPDA) is a 7 tuple
\begin{align*}
      M = (Q, \Sigma, \Gamma, \Delta, q_0, -1, F)
\end{align*}
where
\begin{itemize}
    \item $Q$ is a finite set of states,
    \item $\Sigma$ is a finite input alphabet,
    \item $\Gamma$ is the stack alphabet and is equal to \(\mathbb{N} \cup \{-1\}\)
    \item $\Delta: Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$ is the transition function,
    \item $q_0 \in Q$ is the start state,
    \item $-1 \in \Gamma$ is the bottom of stack symbol,
    \item $F \subseteq Q$ is the set of accepting states.
\end{itemize}

\textbf{Configuration space:} \\
A configuration of an NCPDA is a triple \((q, w, \gamma)\) where \(q \in Q\) is the current state, \(w \in \Sigma^*\) is the remaining input, and \(\gamma \in \Gamma^*\) is the current stack content
similar to a PDA.
\\
\\
\textbf{Computing step relation:} \\
A computing step of an NCPDA is a relation \(\vdash\) on the configuration space defined as follows:
\begin{align*}
    (q, aw, X\gamma) \vdash (p, w, \beta \gamma) \text{ if } (p, \beta) \in \Delta(q, a, X)
\end{align*}
for \(a \in \Sigma \cup \{\epsilon\}\), \(X \in \Gamma\), \(w \in \Sigma^*\), \(\gamma \in \Gamma^*\), and \(\beta \in \Gamma^*\).
\\
\\
\textbf{Acceptance of an input:} \\
An NCPDA accepts an input string \(w \in \Sigma^*\) if there exists a sequence of configurations
\begin{align*}
    (q_0, w, -1) \vdash^* (q_f, \epsilon, \gamma)
\end{align*}
for some \(q_f \in F\) and \(\gamma \in \Gamma^*\). \\
or by empty stack:
\begin{align*}
    (q_0, w, -1) \vdash^* (q, \epsilon, \epsilon)
\end{align*}
for some \(q \in Q\) (not necessarily a final state).
\\
\\
\textbf{NCPDA language:} \\
The language recognized by an NCPDA \(M\) is defined as
\begin{align*}
    L(M) = \{ w \in \Sigma^* \mid M \text{ accepts } w \}
\end{align*}

\end{document}